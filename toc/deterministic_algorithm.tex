%!TEX root = main.tex
\subsection{Deterministic Algorithm and the Proof of Lemma~\ref{lemma:permute}}\label{sec:deterministic}

\begin{lemma}\label{lemma:blocks}
	There exists a~binary regular circuit of size $O(n)$ such
	that any range
	of length at least $\log n$ can be computed in two
	additional binary gates from the gates of the circuit.
	It can be generated by an algorithm in time $O(n)$.
\end{lemma}

\begin{proof}%[Proof of Lemma~\ref{lemma:blocks}]
	We use the block decomposition technique for
	constructing the required circuit.
	Partition the input range $(1,n)$ into $n/\log n$ ranges
	of length $\log n$ and call them blocks. Compute the range
	corresponding to each block (in total size $O(n)$).
	Build a~circuit from Lemma~\ref{lemma:decompose} on
	top of these blocks. The size of this circuit is $O(n)$ since the
	number of blocks is $n/\log n$.
	Compute all prefixes and all suffixes of every block. Since
	the blocks partition the input range $(1,n)$, this also can be done
	with an $O(n)$ size circuit.

	Consider any range of length at least $\log n$. Note that it
	cannot lie entirely inside the block. Hence, any such range can be
	decomposed into three components: a~suffix of a~block, a~sequence
	of whole blocks, and a~prefix of a~block
	(where any of the three components may be empty). For example, for $n=16$,
	a~range $(3,13)$ is decomposed into a~suffix $(3,4)$ of the
	first block, a~sequence $(B_2,B_3)$ of whole blocks, and a~prefix
	$(13,13)$ of the last block:
	\begin{mypic}
		\begin{scope}[scale=.6]
			\foreach \x in {1,...,16}
			\node at (\x,2) {\x};
			\draw[draw=white,fill=gray!20!white] (2.5,0.5) rectangle (13.5,1.5);
			\foreach \x in {1,...,15}
			\draw (\x+0.5,0.5) -- (\x+0.5,1.5);
			\draw (0.5,0.5) rectangle (16.5,1.5);
			\foreach \x in {4,8,12}
			\draw[line width=.5mm] (\x+0.5,0.4) -- (\x+0.5,1.6);
			\foreach \x/\i in {2/1, 6/2, 10/3, 14/4}
			\node at (\x+0.5,0) {$B_{\i}$};
		\end{scope}
	\end{mypic}

	\todo[inline]{Reviewer~1: ``Technically, one needs three additional binary gates to sum up the four parts (the range of blocks is a sum of two)''.~--- Oh, right! Fixed.}

	All sequences of blocks can be precomputed by a circuit of size $O(n)$ using
	the construction from Lemma~\ref{lemma:decompose} (recall that the number of
	blocks is $n / \log n$).
	To combine these three components, one needs two~additional binary gates:
	one to add the~suffix, and another to add the~prefix.
\end{proof}


\begin{proof}[Proof of Lemma~\ref{lemma:permute}]
The $z$~zeroes of~$A$ break its rows into ranges.
Let us call a~range {\em short} is its length is at most $\log n$.
Below, we~show that it is possible to permute the columns of~$A$
so that the total length of all short ranges is at most $o(n)$.
Then, all such short ranges can be computed by a~circuit of size
$o(n)=O(n)=O(z)$. All the remaining ranges can be
computed by a~circuit of size $O(n)$ using Lemma~\ref{lemma:blocks}.

\todo[inline]{Reviewer~3: ``In the beginning of the proof of Lemma 3.6, I was unable to follow the step from "the total length of all short ranges is at most $O(n/\log n)$" to "all such short ranges can be computed by a circuit of size $O(\log n/n \cdot n)$."''~--- Fixed!}

\textbf{Randomized algorithm.}
Permute the columns randomly. A~uniform random permutation
of $n$~objects can be generated in
time~$O(n)$~\cite[Algorithm~P (Shuffling)]{DBLP:books/lib/Knuth98}.
Let us compute the expectation of
the total length of short ranges.
Let us focus on a~single row and a~particular cell in it. Denote the number of
zeroes in the row by~$t$. What is the probability that the cell belongs to
a~short segment? There are two cases to consider.

\todo[inline]{Reviewer~3: ``In the proof of Lemma 3.6, I disagree with the analysis of
the random permutations of the columns. Specifically, it seems like in cases 1
and 2 the proof is not counting the probability of being in a segment of length
at most $\log n$, but instead of length at most $2\log n$. For example, in
case 1, if our cell is the $\log n$-th cell from the left and the nearest zero
is another $\log n$ cells to the right, then our cell is sitting in a segment of
length $2\log n$, not $\log n$ as the proof states.''~--- Thanks, indeed! Fixed.}

\begin{enumerate}
\item The cell is at distance $k$ for $1 \le k \le \log n$ from the border,
i.e., it belongs to the first $\log n$ cells or to the last~$\log n$ cells
(the number of such cells is $2\log n$). Then,
this cell belongs to a~short range if there is at least one zero
in $\log n - k + 1$ cells close to it (on the side opposite to the border).
Hence, one zero must belong to the set of $\log n - k + 1$ cells while the
remaining $t-1$ zeroes may be anywhere. The probability is then at most

\[\sum_{1 \le k \le \log n}(\log n - k + 1) \cdot \frac{\binom{n}{t-1}}{\binom{n}{t}} \le \log n \cdot \frac{t}{n-t+1}=O\left(\frac{\log^2n}{n}\right) \, .\]

\item It is not close to the border (the number of such cells is $n-2\log n$).
Then, there must be a~zero on both sides of the cell: one at
distance $1 \le k < \log n$ on the left and another at distance at most
$\log n - k$ on the right. The probability is then at most

\[\sum_{1 \le k < \log n}(\log n - k) \cdot \frac{\binom{n}{t-2}}{\binom{n}{t}} \le \log^2n \cdot \frac{t(t-1)}{(n-t+1)(n-t+2)}=O\left(\frac{\log^4 n}{n^2}\right) \, .\]

\end{enumerate}
Hence, the expected total length of short ranges in one row is
\[O\left( 2\log n \cdot \frac{\log^2 n}{n} + (n-2\log n) \cdot \frac{\log^4 n}{n^2}\right)=O\left(\frac{\log^4 n}{n}\right) \, .\]
Thus, the expected length of short ranges in the whole
matrix~$A$ is $O(\log^4n)$. By Markov inequality, the probability that
the length of all short ranges is larger than $\frac{n}{\log n}$ is
at most $O(\frac{\log^5 n}{n})$.

\textbf{Deterministic algorithm.}
It will prove convenient to assume that $A$ is a~$t \times t$ matrix with
exactly~$t$ zeros with at most $\log t$ zeroes in every row. To~do this, we let
$t=\max\{n, z\}$ and add a~number of all-ones rows and columns if needed. This
enlargement of the matrix does not make the computation simpler: additional rows
mean additional outputs that can be ignored and additional columns correspond to
redundant variables that can be removed (substituted by~0) once the circuit is
constructed. Below, we show how to deterministically construct a~circuit of size
$O(t)$ for~$A$. To~do this, we present a~greedy algorithm for permuting the
columns of~$A$ in such a~way that the total length of all short segments
is $O(\log^4n)$. This will follow from the fact that all short ranges in the
resulting matrix~$A$ will lie within the last $O(\log^2 t)$ columns.

\todo[inline]{Reviewer~3: ``For the deterministic part of the proof of 3.6 I have a
comment specific to my own reading experience. After reading up to the sentence
beginning "The process will work for at least $t - \log^2 t$ steps," something
about the wording and lack of transition to the next paragraph led me to to
assume that this was the end of the thought and the following paragraph would be
on a different part of the proof. Instead of reading the following explanation,
I stopped to wonder why the process would work for $t - \log^2 t$ steps.''
~\\
--- Thanks, we've revised the text to make the transition clearer.}

We construct the required permutation of columns step by step by a~greedy
algorithm. After step~$r$, we will have a~sequence of the first~$r$ columns
chosen and we will maintain the following properties:
\begin{itemize}
\item For each $i \leq r$, the first $i$~columns contain at least $i$ zeros.
\item There are no short ranges within the first~$r$ rows (apart from those
that can be extended by adding columns on the right).
\end{itemize}

After $t - \log^2 t$ steps, short ranges will only be possible within the last
$\log^2 t + \log t = O(\log^2 t)$ columns. The algorithm itself is presented
below.

On the first step, we pick any column that has a zero in it. Suppose
we have reached step~$r$. We explain how to add a~column on
step $r+1$. Consider the last $\log t$ columns in the currently
constructed sequence. Consider the set $R$~of rows that have
zeros in them. These are exactly the rows that constrain our
choice for the next column. There are two cases.
\begin{enumerate}
\item There are at most $\log t$ rows in~$R$. Then, for each row in~$R$, there
are at most $\log t$ columns that have zeros in this row. In total, there are at
most $\log^2 t$ columns that have zeros in some row of~$R$. Denote the set of
this columns by~$F$. If there is an unpicked column outside of~$F$ that has at
least one zero in it, we add this column to our sequence. Clearly, both
properties are satisfied and the step is over. Otherwise, all other columns
contain only ones, so we add all of them to our sequence, place the columns
from~$F$ to the end of the sequence, and the whole permutation is constructed.
\item There are more that $\log t$ rows in~$R$. This means that the last
$\log t$ columns of the current sequence contain more than $\log t$ zeros. By
the first property, the first $r - \log t$ columns contain at least $r - \log t$
zeros. So overall, in the current sequence of~$r$ columns there are more than
$r$~zeros. Thus, in the remaining $t-r$ columns there are less then $t-r$ zeros
and there is a~column without zeros. We add this column to the sequence.
\end{enumerate}


To implement this algorithm in time $O(t\log^{4}t)$, we store, for each
column~$j$ of~$A$, a~sorted array of rows~$i$ such that $A_{ij}=0$. Since the
total number of zeros~$z$ is at most~$t\log t$, these arrays can be computed in
time $O(t\log^2t)$: if $c_1, \dotsc, c_t$ are the numbers of zeros in the
columns, then sorting the corresponding arrays takes time
\[\sum_{i=1}^{t}c_i \log c_i \le \log(t \log t) \cdot \sum_{i=1}^{t}c_i \le \log(t \log t) \cdot t\log t \, .\]

At every iteration, we need to update the set~$R$. To~do this, we need to remove
some rows from it (from the column that no longer belongs to the stripe of
columns of width $\log t$) and to add the rows of the newly added column. Since
the size of~$|R|$ is always at most~$t$ and the total number of zeros is
$z \le t\log t$, the total running time for all such updates is
$O(t\log^2t)$ (if one uses, e.g., a~balanced binary search tree for
representing~$R$).

If $|R| > \log t$, one just takes an all-one column (all such columns
can be stored in a~list). If $|R| \le \log t$, we need to find a~column outside
of the set~$F$. To~do this, we just scan the list of the yet unpicked columns. For
each column, we first check whether it belongs to the set~$F$. This can be
checked in time $O(\log^2t)$: for every row in~$|R|$, one checks whether this
row belongs to the sorted array of the considered column using binary search in
time $O(\log t)$. Since $|F| \le \log^2t$, we will find a~column outside of~$F$
in time~$O(\log^4 t)$.

\end{proof}
